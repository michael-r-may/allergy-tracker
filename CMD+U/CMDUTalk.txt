TODO: MAKE SURE YOU HAVE DONE A COMPLETE CLEAN BEFORE YOU START
TODO: MAKE SURE YOU SWITCH TO PRESENTATION MODE TO START
TODO: MAKE SURE DO NOT DISTURB IS ON (AND WIFI OFF)
TODO: MAKE SURE CAFFEINE IS ON
TODO: MAKE SURE YOU START WITH TABS:
OpeningSlide.swift
README.md 


INTRODUCTION
Working out how to test an application is difficult enough at the best of times, but how do you approach an existing project that has a large codebase with no tests?


I’ve experienced exactly this challenge on more than one occasion and I want to share what I’ve learned along the way. First of all, let me say that this is not a talk about how to write tests, or even how to write good tests (others here have already picked up those batons). 


This is a talk about being faced with a jungle of code, a small machete, and not much time…


So, the fantastic organisers of this whole conference have asked that we use practical examples with real code as much as possible and so that’s what I am going to do.


WHAT DOES IT DO? 
README.MD
It let’s you log allergens you encounter and the effects you experience afterwards, so that you can find patterns.


WHO WROTE IT? Emily Toop. In 2015. All Objective C. 10,000 lines long.


BUT IT HAS NO TESTS. WE’RE GOING TO FIX THAT.


START WITH COMPILER WARNINGS. 
I find a good place to start is the compiler warnings. By dialing these up you can often root out bugs without doing anything, and catch new ones before you ever run the code. I know I said this talk was about tests, and you probably thinking Unit Tests, but let me try to persuade you that the compiler is your first stage of testing.


See, the compiler
* Performs its tests automatically on each compile
* Makes the build red when they fail
* Reports the violation in a meaningful way (debatable)
* Provides a (limited) level of documentation for what you expected the code to do now, and in the future


COMPILE THE APP AS IS.
FIX THE ONE WARNING. NULLABLE.


IMPROVEMENT ALREADY.
The code is now better than when we first started and it’s only been a few seconds. 


ALREADY ENABLED COMPILER WARNINGS:
Documentation Comments=ON
Four Character Literals=ON
Hidden Local Variables=ON


BOSS LEVEL IT:
Warnings As Errors=ON
Implicit Signedness Conversion = Yes.


25 ERRORS


FIX: Incidence+Extras.m  (NSUInteger)


WOULD DO ALL 24 OTHERS IF HAD TIME
Now, clearly, doing all 24 others is going to take a while and might not be that much fun, so let’s just switch that back off now and move on. 


SWITCH OFF FOR NOW
Implicit Signedness Conversion=No


COMPILER WARNINGS ARE A FORM OF TESTING
Hopefully you get the idea...your compiler warning flags are a form of test. Use them and make sure they always give your code a green pass. They help you to push your code quality up.


SECTION: COMPILER CAN PERFORM OTHER AUTOMATED TESTS FOR US


USE GENERICS ON  getTopIncidentsWithLimit
Whilst we’re here, let’s look at another way the compiler can perform automated tests for us. That same method returns an NSArray.


+(NSArray *)getTopIncidentsWithLimit:(NSUInteger)limit 


NSDICTIONARY<NSSTRING *, NSNUMBER *> 
NSARRAY <NSSTRING *>


CHANGE TYPE TO GET A FAILING TEST AND PROVE IT WORKS


SHOULD PROPAGATE GENERIC TYPE SPECIFIER THIS TO ALL CALLS TO GET TOP INCIDENTS
We could then propagate this to all calls to getTopIncidentsWithLimit to change their use of the return array to be typed to NSArray of NSString rather than just NSArray. Again, we just don’t have time.


STRONGER TYPING IS A CHEAP WIN 
Okay, clearly there are loads more collections that we could use generics with to tighten up the compile time checking, but I don’t have the time and hopefully you are convinced it’s a cheap win.


SECTION: MODEL OBJECTS


Now I typically go and visit the model objects at this point to see if I can tie them down some more and flush out some surprises that way. The models are also typically quite clean and pretty small and, best of all, once you learn about the data model you have a pretty solid insight into the heart of the app.


LOOK AT CORE DATA MODEL
Okay, so we have three model objects and no relationships between them; very simple.


LOOK AT SYMPTOM.H
NSMANAGEDOBJECT
AUTOGENERATED CODE
CATEGORY EXTRAS. NICE.


The problem I have with NSManagedObject classes is how abusable they are, though. Firstly, they exposes their underlying persistence layer mechanism, via the NSManagedObject base class, and, worse, it’s all mutable state. Additionally, since we are using MagicalRecord, I can take one of these objects and MagicalRecord a change back to core data from anywhere I like. 


If I had more time, I would consider whether I might be able to wrap the NSManagedObject inside a PONSO (Plain Old NSObject) so that the storage leak was contained away and the mutation managed by my methods. 


But since we don’t have time, let’s just use the compiler again to tell us some more about this app. After all, one of the points of us writing tests is to learn about how the code works.


MAKE SYMPTOM.H IMMUTABLE
@property (nonatomic, retain, readonly, nonnull) NSString * name;


COMPILING GIVES US 4 ERRORS


SYMPTOM+EXTRAS: setting a UUID that makes reasonable sense.
DATAMANGER: setting the name of a new Symptom, that too makes sense in that class.


SETTINGSTABLEVIEWCONTROLLER: 
Oh, but what’s this...SettingsTableViewController has two places where it is mutating this model object. Let’s take a closer look.


Now, isn’t that interesting...we’ve got a view controller that is doing just what I said I was worried about. It knows that Symptom is an NSManagedObject with mutable properties and is happily abusing that fact to mutate the Symptom or Interaction and save it back to CoreData. 


Oh, and some analytics whilst we’re at it. 


Now, I don’t have time to do the level of refactor that is needed here but hopefully you can see again how the compiler can help you.


You can see how just by changing the signature of a property to be as restrictive as we would hope it to be, we can audit the code with the help of the compiler and, once any issues are remedied, ensure that it complies with our assumptions forever more.


SECTION: UNIT TESTS: QUICK ACTIONS


WRITE SOME UNIT TESTS NOW:


QUICKACTIONS.H : WHAT DOES CLASS DO?
3D TOUCH SHORTCUTS ON APP ICON


This looks like a good candidate. We have some model generation, and some interaction with the UIKit framework. 


LOOK AT addTopIncidents:
WHY CLASS METHODS ARE GOOD
WHY THIS IS NOT PURE (GLOBAL STATE)


APPLY GENERIC TYPE TO NSARRAY, NSDICTIONARY


COMPILE


EXTRACTION:
EXTRACT SHORTCUT TITLE


+(nonnull NSString *)shortcutTitleForincidentName:(nonnull NSString *)name {
    return [NSString stringWithFormat:@"Log %@", [name capitalizedString]];
}


DO NOT USE AFTER EXTRACTION. TEST FIRST. THEN USE.
Now, let’s use it. Oh, but hang on. We’ve extracted it, but we’ve not tested it.


It’s really tempting now to just plough on but that’s not right. Let’s write some tests.
QUICKACTIONSTESTS.SWIFT
UNCOMMENT
RUN TEST


FIX METHOD NOT EXPOSED IN HEADER FILE
@interface QuickActions (Testable)
+(nonnull NSString *)shortcutTitleForIncidentName:(nonnull NSString *)name;
@end


RUN TEST


NORMALLY: WRITE MORE TESTS
Obviously, we’d now go on to write more tests against this method before we do anything more, but we don’t have time.


NORMALLY: EXTRACT CREATING SHORTCUT ITEMS
I would then look at extracting the loop which turns incident names into UIMutableApplicationShortcutItem objects. This is then very testable, since, it can be made as a pure function that takes one input and transforms it into a related output. In this case, short cut items from 


Again, time is against me, so let’s assume I did that too. Check the final version on GitHub for all this stuff I am glossing over.


Now we have tests we can be reassured that we are transforming the strings into objects that have the state we expect. So we’re ready to collapse the original method into something that would be much more readable - just a handful of lines long. 


Again, you are just going to have to look at the final project for that.


SECTION: WHERE IS THE SWIFT:
Now, you might be thinking, where’s the Swift, really. I mean, who wants to write Objective-C? But the truth is that if you are working on a project without tests, given that there have been iOS apps since 2008 whereas there have only been Swift apps since 2014, there is a very good chance you’ll be writing tests for Objective-C code. 


ONLY ONCE WE HAVE TESTS, CAN WE CONFIDENTLY REFACTOR OBJ-C INTO SWIFT
However, now we’ve added some tests, and those tests that are in Swift, we are finally in a position where we could go back and refactor that code into Swift too. And the best thing is that we would now have confidence that we won’t break anything because, if we do, we have tests to catch that.[a]


So, now, we are not only writing tests in an app that had none, we’re leveraging those tests to help us remove the Objective-C code.




SECTION: PAGINGVIEWCONTROLLER.H


PAGINGVIEWCONTROLLER.H : TALK THROUGH METHODS


PAGINGVIEWCONTROLLER.M
MOST IMPORTANT METHOD: _changePageFromIndex:toIndex:


TESTABLE STATE: self.headerView.titleLabel = newLabel;


POWERING METHOD: _labelForPageAtIndex: > titleForPageAtIndex:
Ah, so titleForPageAtIndex: returns the actual string that become the text of the UILabel.


VISIT FIRST IMPLEMENTATION OF titleForPageAtIndex:
WHY NSEXCEPTION IS GOOD
IN SWIFT THIS WOULD BE ASSERT OR PRECONDITIONFAILURE


VISIT LAST IMPLEMENTATION OF titleForPageAtIndex:
BACK IN PAGINGVIEWCONTROLLER.M
CODE SMELL
GOOD CANDIDATE FOR EXTRACTION
ALREADY KNOW IT HAS NO SELF REFERENCES


WHERE TO EXTRACT TO?
Uses rr_isSameDayAsDate - NSDate+Utilities
Uses rr_dateFormatter - NSDateFormatter+Utilities


NEEDS A NEW CATEGORY ON NSDATE
DELETE OLD VERSION
OPEN NEW VERSION: NSDate+TitleTextForDate.h
ALSO: NOW A CLASS METHOD TOO


COMPILE. FIX ERROR.
COMPILE.


WRITE TESTS:
OPEN: NSDate+TitleTextForDateTests.swift 
UNCOMMENT
RUN. PASS.
CHANGE. “Tomorrow”. RUN. FAIL. GOOD. 
CHANGE BACK TO PASS.


NORMALLY: MORE TESTS: “Tomorrow”, “Yesterday”, distantPast, distantFuture, nil


AGAIN. TEST SUITE MEANS WE CAN REWRITE IN SWIFT.


RUNNING OUT OF TIME.


SECTION: OUTRO:
I hope I’ve shown you that no matter what state a project is in when you first come to it, you can always find somewhere to get your first tests attached to.


And with each set of tests...


* Your codebase gets stronger because you find more bugs and you tighten things up such that there is less opportunities for similar bugs in the future.


* You slowly give yourself more and more reassurance that any changes you make to the code are not breaking something someplace else.


* You also reduce the amount of manual testing you need to to in the future, because you’ll be catching many more bugs at test time than at runtime. That’s not to say you don’t need manual tests, but just that you can focus those tests on more interesting test cases.


SECTION: THANK YOU

THANK YOU. USEFUL AND INTERESTING.
FEEDBACK DURING THE BREAK.

